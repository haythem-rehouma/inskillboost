<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 7 - Interfaces et Abstractions - Formation Java ComplÃ¨te</title>
    
    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Highlight.js CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --java-orange: #f89820;
            --java-blue: #5382a1;
            --success-color: #059669;
            --warning-color: #d97706;
            --info-color: #0284c7;
            --dark-color: #1f2937;
            --light-bg: #f8fafc;
            --border-color: #e2e8f0;
            --text-muted: #64748b;
            --question-bg: #f1f5f9;
            --answer-bg: #dcfce7;
            --explanation-bg: #fef3c7;
            --code-bg: #0f172a;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--light-bg);
            color: var(--dark-color);
            line-height: 1.6;
        }

        .navbar {
            background: linear-gradient(135deg, var(--java-orange), var(--java-blue));
            backdrop-filter: blur(10px);
        }

        .sidebar {
            position: sticky;
            top: 100px;
            height: calc(100vh - 120px);
            overflow-y: auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
        }

        .main-content {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .content-header {
            background: linear-gradient(135deg, var(--java-orange), var(--java-blue));
            color: white;
            padding: 2rem;
            text-align: center;
        }

        .section-title {
            color: var(--java-orange);
            font-weight: 700;
            font-size: 1.5rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .code-block {
            background: var(--code-bg);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            overflow-x: auto;
        }

        .exercise-card {
            background: var(--question-bg);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid var(--java-orange);
        }

        .solution-card {
            background: var(--answer-bg);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1rem 0;
            border-left: 4px solid var(--success-color);
        }

        .concept-highlight {
            background: linear-gradient(135deg, rgba(248, 152, 32, 0.1), rgba(83, 130, 161, 0.1));
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid var(--java-orange);
        }

        .interface-diagram {
            background: #f8fafc;
            border: 2px solid var(--info-color);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
        }

        .design-pattern {
            background: white;
            border: 2px solid var(--success-color);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .progress-bar {
            background: linear-gradient(135deg, var(--java-orange), var(--java-blue));
            height: 100%;
            width: 58.33%; /* 7/12 modules */
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container">
            <a class="navbar-brand" href="../">
                <i class="fas fa-graduation-cap me-2"></i>
                InSkillBoost - Java
            </a>
            <div class="navbar-nav ms-auto">
                <a class="nav-link" href="../">Retour Hub</a>
                <a class="nav-link" href="./">Modules Java</a>
            </div>
        </div>
    </nav>

    <div class="container-fluid" style="margin-top: 80px;">
        <div class="row">
            <!-- Sidebar -->
            <div class="col-lg-3">
                <div class="sidebar">
                    <div style="color: var(--java-orange); font-weight: 600; margin-bottom: 1rem;">
                        <i class="fas fa-puzzle-piece me-2"></i>
                        Module 7 - Interfaces et Abstractions
                    </div>
                    
                    <div style="background: var(--border-color); height: 4px; border-radius: 2px; margin: 1rem 0;">
                        <div class="progress-bar"></div>
                    </div>
                    <small class="text-muted d-block mb-3">Module 7 sur 12</small>
                    
                    <a href="#introduction-interfaces" style="display: block; padding: 0.5rem 0; color: var(--java-orange); text-decoration: none;">Introduction Interfaces</a>
                    <a href="#declaration-interfaces" style="display: block; padding: 0.5rem 0; color: var(--text-muted); text-decoration: none;">DÃ©claration Interfaces</a>
                    <a href="#implementation-multiple" style="display: block; padding: 0.5rem 0; color: var(--text-muted); text-decoration: none;">ImplÃ©mentation Multiple</a>
                    <a href="#methodes-default" style="display: block; padding: 0.5rem 0; color: var(--text-muted); text-decoration: none;">MÃ©thodes Default</a>
                    <a href="#methodes-statiques" style="display: block; padding: 0.5rem 0; color: var(--text-muted); text-decoration: none;">MÃ©thodes Statiques</a>
                    <a href="#interfaces-fonctionnelles" style="display: block; padding: 0.5rem 0; color: var(--text-muted); text-decoration: none;">Interfaces Fonctionnelles</a>
                    <a href="#design-patterns" style="display: block; padding: 0.5rem 0; color: var(--text-muted); text-decoration: none;">Design Patterns</a>
                    <a href="#abstraction-vs-interface" style="display: block; padding: 0.5rem 0; color: var(--text-muted); text-decoration: none;">Abstraction vs Interface</a>
                    <a href="#exercices" style="display: block; padding: 0.5rem 0; color: var(--text-muted); text-decoration: none;">Exercices (14)</a>
                </div>
            </div>

            <!-- Main Content -->
            <div class="col-lg-9">
                <div class="main-content">
                    <div class="content-header">
                        <h1>Module 7 - Interfaces et Abstractions</h1>
                        <p class="lead mb-0">MaÃ®trisez les contrats et l'architecture logicielle</p>
                    </div>

                    <div style="padding: 2rem;">
                        <!-- Introduction Interfaces -->
                        <section id="introduction-interfaces" style="margin-bottom: 3rem;">
                            <h2 class="section-title">
                                <i class="fas fa-handshake"></i>
                                Qu'est-ce qu'une Interface ? Le CONTRAT Ultime !
                            </h2>
                            
                            <p>Une <strong>interface</strong> en Java est comme un <strong>contrat lÃ©gal</strong> ! Elle dÃ©finit ce qu'une classe DOIT faire, sans dire COMMENT elle doit le faire. C'est l'abstraction totale et la solution Java pour simuler l'hÃ©ritage multiple.</p>

                            <div class="concept-highlight">
                                <h5>Analogie : Interface comme un Contrat de Travail</h5>
                                <p>Imaginez que vous embauchez diffÃ©rents types d'employÃ©s :</p>
                                <ul>
                                    <li>ğŸ¢ <strong>Contrat "EmployÃ©" :</strong> Doit arriver Ã  l'heure, travailler 8h, prendre des pauses</li>
                                    <li>ğŸ‘¨â€ğŸ’» <strong>DÃ©veloppeur :</strong> Signe le contrat + code des applications</li>
                                    <li>ğŸ¨ <strong>Designer :</strong> Signe le contrat + crÃ©e des designs</li>
                                    <li>ğŸ“Š <strong>Manager :</strong> Signe le contrat + gÃ¨re une Ã©quipe</li>
                                </ul>
                                <p><strong>Le contrat</strong> (interface) dÃ©finit les OBLIGATIONS communes, chaque employÃ© (classe) l'implÃ©mente Ã  SA maniÃ¨re !</p>
                            </div>

                            <h4>Interface vs Classe Abstraite vs Classe ConcrÃ¨te</h4>
                            <div class="row">
                                <div class="col-md-4">
                                    <div class="concept-highlight">
                                        <h6>ğŸ”— Interface</h6>
                                        <ul>
                                            <li><strong>100% abstrait</strong> (avant Java 8)</li>
                                            <li>MÃ©thodes <code>public abstract</code></li>
                                            <li>Constantes <code>public static final</code></li>
                                            <li>ImplÃ©mentation multiple</li>
                                            <li>Relation "PEUT-FAIRE"</li>
                                        </ul>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="concept-highlight">
                                        <h6>ğŸ—ï¸ Classe Abstraite</h6>
                                        <ul>
                                            <li><strong>Partiellement abstrait</strong></li>
                                            <li>MÃ©thodes abstraites + concrÃ¨tes</li>
                                            <li>Attributs normaux</li>
                                            <li>HÃ©ritage simple uniquement</li>
                                            <li>Relation "EST-UN"</li>
                                        </ul>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="concept-highlight">
                                        <h6>ğŸ  Classe ConcrÃ¨te</h6>
                                        <ul>
                                            <li><strong>0% abstrait</strong></li>
                                            <li>Toutes mÃ©thodes implÃ©mentÃ©es</li>
                                            <li>Instanciable directement</li>
                                            <li>HÃ©ritage simple</li>
                                            <li>Objet rÃ©el utilisable</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>

                            <h4>Exemple Concret : Pourquoi les Interfaces sont GÃ‰NIALES</h4>
                            <div class="code-block">
<pre><code class="language-java">/**
 * PROBLÃˆME SANS INTERFACES : Code rigide et limitÃ©
 */
class SansInterfaces {
    public static void main(String[] args) {
        // Sans interfaces, on est limitÃ© par l'hÃ©ritage simple
        Chien chien = new Chien();
        Oiseau oiseau = new Oiseau();
        
        // Impossible de traiter uniformÃ©ment les animaux qui nagent
        // Car un Chien ne peut pas hÃ©riter d'Animal ET de Nageur
        // C'est lÃ  que les interfaces sauvent la mise !
    }
}

/**
 * SOLUTION AVEC INTERFACES : FlexibilitÃ© maximale !
 */

// INTERFACES = CONTRATS DE CAPACITÃ‰S
interface Volant {
    void voler();
    void atterrir();
    double getAltitude();
}

interface Nageur {
    void nager();
    void plonger();
    double getProfondeur();
}

interface Marcheur {
    void marcher();
    void courir();
    void sauter();
}

// CLASSE DE BASE (hÃ©ritage simple)
abstract class Animal {
    protected String nom;
    protected int age;
    
    public Animal(String nom, int age) {
        this.nom = nom;
        this.age = age;
    }
    
    public abstract void faireDuBruit();
    
    public void dormir() {
        System.out.println(nom + " dort paisiblement");
    }
}

// IMPLÃ‰MENTATIONS AVEC INTERFACES MULTIPLES
class Canard extends Animal implements Volant, Nageur, Marcheur {
    private double altitude = 0;
    private double profondeur = 0;
    
    public Canard(String nom, int age) {
        super(nom, age);
    }
    
    @Override
    public void faireDuBruit() {
        System.out.println(nom + " fait: Coin coin ! ğŸ¦†");
    }
    
    // Interface Volant
    @Override
    public void voler() {
        altitude = 50; // Les canards volent bas
        System.out.println(nom + " vole Ã  " + altitude + "m d'altitude ğŸ¦†âœˆï¸");
    }
    
    @Override
    public void atterrir() {
        altitude = 0;
        System.out.println(nom + " se pose sur l'eau ğŸ¦†ğŸ’§");
    }
    
    @Override
    public double getAltitude() { return altitude; }
    
    // Interface Nageur
    @Override
    public void nager() {
        profondeur = 0;
        System.out.println(nom + " nage Ã  la surface ğŸ¦†ğŸŠ");
    }
    
    @Override
    public void plonger() {
        profondeur = 2; // PlongÃ©e peu profonde
        System.out.println(nom + " plonge Ã  " + profondeur + "m ğŸ¦†ğŸ¤¿");
    }
    
    @Override
    public double getProfondeur() { return profondeur; }
    
    // Interface Marcheur
    @Override
    public void marcher() {
        System.out.println(nom + " se dandine sur ses pattes ğŸ¦†ğŸš¶");
    }
    
    @Override
    public void courir() {
        System.out.println(nom + " court en battant des ailes ğŸ¦†ğŸƒ");
    }
    
    @Override
    public void sauter() {
        System.out.println(nom + " sautille maladroitement ğŸ¦†ğŸ¦˜");
    }
}

class Pingouin extends Animal implements Nageur, Marcheur {
    private double profondeur = 0;
    
    public Pingouin(String nom, int age) {
        super(nom, age);
    }
    
    @Override
    public void faireDuBruit() {
        System.out.println(nom + " fait: Honk honk ! ğŸ§");
    }
    
    // Interface Nageur (expert !)
    @Override
    public void nager() {
        System.out.println(nom + " nage comme une torpille ! ğŸ§ğŸš€");
    }
    
    @Override
    public void plonger() {
        profondeur = 200; // PlongÃ©e profonde !
        System.out.println(nom + " plonge Ã  " + profondeur + "m de profondeur ! ğŸ§ğŸŒŠ");
    }
    
    @Override
    public double getProfondeur() { return profondeur; }
    
    // Interface Marcheur
    @Override
    public void marcher() {
        System.out.println(nom + " marche en se dandinant ğŸ§ğŸš¶");
    }
    
    @Override
    public void courir() {
        System.out.println(nom + " glisse sur le ventre ! ğŸ§ğŸ›·");
    }
    
    @Override
    public void sauter() {
        System.out.println(nom + " saute de rocher en rocher ğŸ§ğŸª¨");
    }
    
    // Note: Pingouin ne vole PAS â†’ n'implÃ©mente pas Volant !
}

class Avion implements Volant {
    private String modele;
    private double altitude = 0;
    
    public Avion(String modele) {
        this.modele = modele;
    }
    
    @Override
    public void voler() {
        altitude = 10000; // Les avions volent haut !
        System.out.println("Avion " + modele + " vole Ã  " + altitude + "m âœˆï¸");
    }
    
    @Override
    public void atterrir() {
        altitude = 0;
        System.out.println("Avion " + modele + " atterrit ğŸ›¬");
    }
    
    @Override
    public double getAltitude() { return altitude; }
}

// DÃ‰MONSTRATION DE LA PUISSANCE DES INTERFACES
public class DemonstrationInterfaces {
    public static void main(String[] args) {
        System.out.println("ğŸŒŸ === MAGIE DES INTERFACES ===");
        
        // CrÃ©er diffÃ©rents objets
        Canard donald = new Canard("Donald", 3);
        Pingouin pingu = new Pingouin("Pingu", 2);
        Avion boeing = new Avion("Boeing 747");
        
        System.out.println("\nğŸ¦† === CANARD POLYVALENT ===");
        donald.faireDuBruit();
        donald.marcher();
        donald.voler();
        donald.nager();
        donald.plonger();
        
        System.out.println("\nğŸ§ === PINGOUIN EXPERT NAGEUR ===");
        pingu.faireDuBruit();
        pingu.marcher();
        pingu.nager();
        pingu.plonger();
        // pingu.voler(); â† ERREUR ! Pingouin n'implÃ©mente pas Volant
        
        System.out.println("\nâœˆï¸ === AVION VOLANT ===");
        boeing.voler();
        boeing.atterrir();
        
        System.out.println("\nğŸ­ === POLYMORPHISME AVEC INTERFACES ===");
        
        // POLYMORPHISME : MÃªme interface, objets diffÃ©rents !
        Volant[] objetsVolants = {donald, boeing};
        for (Volant volant : objetsVolants) {
            volant.voler();
            System.out.println("Altitude: " + volant.getAltitude() + "m");
        }
        
        Nageur[] nageursExperts = {donald, pingu};
        for (Nageur nageur : nageursExperts) {
            nageur.plonger();
            System.out.println("Profondeur: " + nageur.getProfondeur() + "m");
        }
        
        System.out.println("\nğŸ’¡ AVANTAGES DES INTERFACES :");
        System.out.println("âœ… Canard implÃ©mente 3 interfaces (Volant + Nageur + Marcheur)");
        System.out.println("âœ… Pingouin implÃ©mente 2 interfaces (Nageur + Marcheur)");
        System.out.println("âœ… Avion implÃ©mente 1 interface (Volant)");
        System.out.println("âœ… Polymorphisme flexible selon les capacitÃ©s !");
        System.out.println("âœ… Code rÃ©utilisable et extensible !");
    }
}

/*
RÃ‰SULTAT D'EXÃ‰CUTION :
ğŸŒŸ === MAGIE DES INTERFACES ===

ğŸ¦† === CANARD POLYVALENT ===
Donald fait: Coin coin ! ğŸ¦†
Donald se dandine sur ses pattes ğŸ¦†ğŸš¶
Donald vole Ã  50.0m d'altitude ğŸ¦†âœˆï¸
Donald nage Ã  la surface ğŸ¦†ğŸŠ
Donald plonge Ã  2.0m ğŸ¦†ğŸ¤¿

ğŸ§ === PINGOUIN EXPERT NAGEUR ===
Pingu fait: Honk honk ! ğŸ§
Pingu marche en se dandinant ğŸ§ğŸš¶
Pingu nage comme une torpille ! ğŸ§ğŸš€
Pingu plonge Ã  200.0m de profondeur ! ğŸ§ğŸŒŠ

âœˆï¸ === AVION VOLANT ===
Avion Boeing 747 vole Ã  10000.0m âœˆï¸
Avion Boeing 747 atterrit ğŸ›¬

ğŸ­ === POLYMORPHISME AVEC INTERFACES ===
Donald vole Ã  50.0m d'altitude ğŸ¦†âœˆï¸
Altitude: 50.0m
Avion Boeing 747 vole Ã  10000.0m âœˆï¸
Altitude: 10000.0m
Donald plonge Ã  2.0m ğŸ¦†ğŸ¤¿
Profondeur: 2.0m
Pingu plonge Ã  200.0m de profondeur ! ğŸ§ğŸŒŠ
Profondeur: 200.0m

MAGIE RÃ‰VÃ‰LÃ‰E :
ğŸ¯ MÃªme mÃ©thode voler() â†’ Comportements diffÃ©rents selon l'objet
ğŸ¯ Polymorphisme basÃ© sur les CAPACITÃ‰S, pas l'hÃ©ritage
ğŸ¯ FlexibilitÃ© maximale : un objet peut avoir plusieurs "talents"
*/</code></pre>
                            </div>

                            <div class="concept-highlight">
                                <h5>CaractÃ©ristiques des Interfaces :</h5>
                                <ul>
                                    <li><strong>Contrat :</strong> DÃ©finit QUOI faire, pas COMMENT</li>
                                    <li><strong>Abstraction pure :</strong> Toutes les mÃ©thodes sont abstraites (avant Java 8)</li>
                                    <li><strong>HÃ©ritage multiple :</strong> Une classe peut implÃ©menter plusieurs interfaces</li>
                                    <li><strong>Constantes :</strong> Variables public static final par dÃ©faut</li>
                                    <li><strong>Ã‰volution :</strong> MÃ©thodes default et static depuis Java 8</li>
                                </ul>
                            </div>

                            <div class="interface-diagram">
                                <h6>DiffÃ©rence HÃ©ritage vs Interface :</h6>
                                <pre>
HÃ‰RITAGE (extends)              INTERFACE (implements)
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€              â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        Animal                     Volant    Nageur
          â”‚                          â”‚         â”‚
    â”Œâ”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”                   â”‚         â”‚
  Chien      Chat                   â”‚         â”‚
                                    â”‚         â”‚
    Relation "EST-UN"         â”Œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”
    (Chien EST UN Animal)     â”‚     â”‚         â”‚     â”‚
                           Oiseau Avion   Poisson Canard
                                              â”‚
                                        (implÃ©mente les 2)
                                        
    Relation "PEUT-FAIRE"
    (Canard PEUT voler ET nager)
                </pre>
                            </div>
                        </section>

                        <!-- DÃ©claration Interfaces -->
                        <section id="declaration-interfaces" style="margin-bottom: 3rem;">
                            <h2 class="section-title">
                                <i class="fas fa-file-contract"></i>
                                DÃ©claration et ImplÃ©mentation d'Interfaces
                            </h2>
                            
                            <h4>Syntaxe de Base</h4>
                            <div class="code-block">
<pre><code class="language-java">// Interface pour les objets volants
public interface Volant {
    // Constantes (public static final par dÃ©faut)
    double VITESSE_LUMIERE = 299792458; // m/s
    int ALTITUDE_MAX_CIVILE = 12000;    // mÃ¨tres
    
    // MÃ©thodes abstraites (public abstract par dÃ©faut)
    void decoller();
    void atterrir();
    void voler(double altitude);
    double getAltitudeActuelle();
    double getVitesseVol();
}

// Interface pour les objets nageurs
public interface Nageur {
    // Constantes
    double PROFONDEUR_MAX_HUMAIN = 330; // mÃ¨tres
    
    // MÃ©thodes abstraites
    void plonger();
    void faireSurface();
    void nager(double distance);
    double getProfondeurActuelle();
    double getVitesseNage();
}

// Interface pour les vÃ©hicules Ã©lectriques
public interface Electrique {
    double TENSION_STANDARD = 400; // Volts
    
    void charger(int minutes);
    void activerModeEco();
    double getNiveauBatterie();
    double getAutonomieRestante();
}</code></pre>
                            </div>

                            <h4>ImplÃ©mentation Simple</h4>
                            <div class="code-block">
<pre><code class="language-java">// Classe implÃ©mentant une interface
public class Avion implements Volant {
    private String modele;
    private double altitudeActuelle;
    private double vitesseActuelle;
    private boolean enVol;
    
    public Avion(String modele) {
        this.modele = modele;
        this.altitudeActuelle = 0;
        this.vitesseActuelle = 0;
        this.enVol = false;
        System.out.println("Avion " + modele + " crÃ©Ã©");
    }
    
    // ImplÃ©mentation obligatoire des mÃ©thodes de l'interface
    @Override
    public void decoller() {
        if (!enVol) {
            System.out.println("ğŸ›« " + modele + " dÃ©colle...");
            enVol = true;
            altitudeActuelle = 100; // Altitude initiale
            vitesseActuelle = 250;  // Vitesse de croisiÃ¨re
        } else {
            System.out.println("L'avion est dÃ©jÃ  en vol");
        }
    }
    
    @Override
    public void atterrir() {
        if (enVol) {
            System.out.println("ğŸ›¬ " + modele + " atterrit...");
            enVol = false;
            altitudeActuelle = 0;
            vitesseActuelle = 0;
        } else {
            System.out.println("L'avion est dÃ©jÃ  au sol");
        }
    }
    
    @Override
    public void voler(double altitude) {
        if (enVol) {
            if (altitude <= ALTITUDE_MAX_CIVILE) {
                this.altitudeActuelle = altitude;
                System.out.printf("%s vole maintenant Ã  %.0f mÃ¨tres%n", modele, altitude);
            } else {
                System.out.println("Altitude trop Ã©levÃ©e ! Maximum autorisÃ©: " + ALTITUDE_MAX_CIVILE + "m");
            }
        } else {
            System.out.println("L'avion doit d'abord dÃ©coller");
        }
    }
    
    @Override
    public double getAltitudeActuelle() {
        return altitudeActuelle;
    }
    
    @Override
    public double getVitesseVol() {
        return vitesseActuelle;
    }
    
    // MÃ©thodes spÃ©cifiques Ã  l'avion
    public void afficherStatutVol() {
        System.out.println("=== STATUT VOL " + modele + " ===");
        System.out.println("En vol: " + enVol);
        System.out.printf("Altitude: %.0f m%n", altitudeActuelle);
        System.out.printf("Vitesse: %.0f km/h%n", vitesseActuelle);
    }
}</code></pre>
                            </div>

                            <h4>ImplÃ©mentation Multiple</h4>
                            <div class="code-block">
<pre><code class="language-java">// Classe implÃ©mentant plusieurs interfaces
public class Canard implements Volant, Nageur {
    private String nom;
    private double altitudeActuelle;
    private double profondeurActuelle;
    private boolean enVol;
    private boolean sousEau;
    
    public Canard(String nom) {
        this.nom = nom;
        this.altitudeActuelle = 0;
        this.profondeurActuelle = 0;
        this.enVol = false;
        this.sousEau = false;
        System.out.println("Canard " + nom + " crÃ©Ã© - Peut voler ET nager !");
    }
    
    // ImplÃ©mentation de l'interface Volant
    @Override
    public void decoller() {
        if (!enVol && !sousEau) {
            enVol = true;
            altitudeActuelle = 50; // Les canards volent bas
            System.out.println("ğŸ¦† " + nom + " dÃ©colle et vole Ã  " + altitudeActuelle + "m");
        } else if (sousEau) {
            System.out.println(nom + " doit d'abord faire surface");
        } else {
            System.out.println(nom + " vole dÃ©jÃ ");
        }
    }
    
    @Override
    public void atterrir() {
        if (enVol) {
            enVol = false;
            altitudeActuelle = 0;
            System.out.println("ğŸ¦† " + nom + " se pose sur l'eau");
        }
    }
    
    @Override
    public void voler(double altitude) {
        if (enVol) {
            if (altitude <= 500) { // Les canards ne volent pas trÃ¨s haut
                this.altitudeActuelle = altitude;
                System.out.printf("%s vole Ã  %.0f mÃ¨tres%n", nom, altitude);
            } else {
                System.out.println("Altitude trop Ã©levÃ©e pour un canard ! Max: 500m");
            }
        }
    }
    
    // ImplÃ©mentation de l'interface Nageur
    @Override
    public void plonger() {
        if (!enVol && !sousEau) {
            sousEau = true;
            profondeurActuelle = 2; // Les canards plongent peu profond
            System.out.println("ğŸ¦† " + nom + " plonge sous l'eau (" + profondeurActuelle + "m)");
        } else if (enVol) {
            System.out.println(nom + " doit d'abord atterrir");
        }
    }
    
    @Override
    public void faireSurface() {
        if (sousEau) {
            sousEau = false;
            profondeurActuelle = 0;
            System.out.println("ğŸ¦† " + nom + " fait surface");
        }
    }
    
    @Override
    public void nager(double distance) {
        if (!enVol && !sousEau) {
            System.out.printf("%s nage %.1f mÃ¨tres Ã  la surface%n", nom, distance);
        } else if (sousEau) {
            System.out.printf("%s nage %.1f mÃ¨tres sous l'eau%n", nom, distance);
        } else {
            System.out.println(nom + " doit d'abord atterrir pour nager");
        }
    }
    
    @Override
    public double getAltitudeActuelle() { return altitudeActuelle; }
    
    @Override
    public double getVitesseVol() { return enVol ? 60 : 0; } // km/h
    
    @Override
    public double getProfondeurActuelle() { return profondeurActuelle; }
    
    @Override
    public double getVitesseNage() { return 5; } // km/h
    
    // MÃ©thode spÃ©cifique au canard
    public void coincoiner() {
        System.out.println("ğŸ¦† " + nom + " fait: Coin coin !");
    }
    
    public void afficherStatut() {
        System.out.println("=== STATUT " + nom.toUpperCase() + " ===");
        if (enVol) {
            System.out.println("Ã‰tat: En vol Ã  " + altitudeActuelle + "m");
        } else if (sousEau) {
            System.out.println("Ã‰tat: Sous l'eau Ã  " + profondeurActuelle + "m");
        } else {
            System.out.println("Ã‰tat: Ã€ la surface de l'eau");
        }
    }
}</code></pre>
                            </div>
                        </section>

                        <!-- MÃ©thodes Default -->
                        <section id="methodes-default" style="margin-bottom: 3rem;">
                            <h2 class="section-title">
                                <i class="fas fa-cog"></i>
                                MÃ©thodes Default et Statiques (Java 8+)
                            </h2>
                            
                            <p>Depuis Java 8, les interfaces peuvent contenir des mÃ©thodes avec implÃ©mentation : les mÃ©thodes <code>default</code> et <code>static</code>.</p>

                            <div class="code-block">
<pre><code class="language-java">// Interface moderne avec mÃ©thodes default et static
public interface Drawable {
    // Constantes
    String DEFAULT_COLOR = "BLACK";
    int DEFAULT_THICKNESS = 1;
    
    // MÃ©thode abstraite (obligatoire Ã  implÃ©menter)
    void draw();
    
    // MÃ©thode default (implÃ©mentation par dÃ©faut)
    default void setColor(String color) {
        System.out.println("Couleur changÃ©e vers: " + color);
    }
    
    default void setThickness(int thickness) {
        if (thickness > 0) {
            System.out.println("Ã‰paisseur dÃ©finie Ã : " + thickness);
        } else {
            System.out.println("Ã‰paisseur invalide, utilisation de la valeur par dÃ©faut");
        }
    }
    
    default void drawWithBorder() {
        System.out.println("--- DÃ©but du dessin avec bordure ---");
        draw(); // Appel de la mÃ©thode abstraite
        System.out.println("--- Fin du dessin avec bordure ---");
    }
    
    // MÃ©thode statique (appartient Ã  l'interface)
    static void printDrawingInstructions() {
        System.out.println("=== INSTRUCTIONS DE DESSIN ===");
        System.out.println("1. DÃ©finir la couleur avec setColor()");
        System.out.println("2. DÃ©finir l'Ã©paisseur avec setThickness()");
        System.out.println("3. Dessiner avec draw()");
        System.out.println("4. Optionnel: drawWithBorder() pour une bordure");
    }
    
    static String getDefaultColor() {
        return DEFAULT_COLOR;
    }
}

// Interface pour les objets redimensionnables
public interface Resizable {
    void resize(double facteur);
    
    default void doubleSize() {
        resize(2.0);
        System.out.println("Taille doublÃ©e");
    }
    
    default void halfSize() {
        resize(0.5);
        System.out.println("Taille rÃ©duite de moitiÃ©");
    }
    
    static void printResizeHelp() {
        System.out.println("Facteur > 1 : agrandir, Facteur < 1 : rÃ©duire");
    }
}

// Classe implÃ©mentant plusieurs interfaces avec mÃ©thodes default
public class CarreDessinable implements Drawable, Resizable {
    private double cote;
    private String couleur;
    private int epaisseur;
    
    public CarreDessinable(double cote) {
        this.cote = cote;
        this.couleur = Drawable.getDefaultColor(); // Utilisation mÃ©thode static
        this.epaisseur = DEFAULT_THICKNESS;
        System.out.println("CarrÃ© crÃ©Ã©: cÃ´tÃ© " + cote);
    }
    
    // ImplÃ©mentation obligatoire de draw()
    @Override
    public void draw() {
        System.out.println("Dessin d'un carrÃ© " + couleur + " (cÃ´tÃ©: " + cote + "):");
        
        for (int i = 0; i < (int)cote; i++) {
            for (int j = 0; j < (int)cote; j++) {
                if (i == 0 || i == (int)cote - 1 || j == 0 || j == (int)cote - 1) {
                    System.out.print("â–ˆ");
                } else {
                    System.out.print(" ");
                }
            }
            System.out.println();
        }
    }
    
    // ImplÃ©mentation obligatoire de resize()
    @Override
    public void resize(double facteur) {
        if (facteur > 0) {
            double ancienCote = cote;
            cote *= facteur;
            System.out.printf("Redimensionnement: %.1f â†’ %.1f (facteur: %.2f)%n", 
                            ancienCote, cote, facteur);
        } else {
            System.out.println("Facteur de redimensionnement invalide");
        }
    }
    
    // RedÃ©finition optionnelle d'une mÃ©thode default
    @Override
    public void setColor(String color) {
        String ancienneCouleur = this.couleur;
        this.couleur = color;
        System.out.println("Couleur du carrÃ©: " + ancienneCouleur + " â†’ " + color);
    }
    
    // MÃ©thode spÃ©cifique
    public double calculerAire() {
        return cote * cote;
    }
    
    public double calculerPerimetre() {
        return 4 * cote;
    }
}</code></pre>
                            </div>
                        </section>

                        <!-- Design Patterns -->
                        <section id="design-patterns" style="margin-bottom: 3rem;">
                            <h2 class="section-title">
                                <i class="fas fa-drafting-compass"></i>
                                Design Patterns avec Interfaces
                            </h2>
                            
                            <h4>1. Pattern Strategy</h4>
                            <p>Permet de changer d'algorithme Ã  l'exÃ©cution.</p>
                            
                            <div class="code-block">
<pre><code class="language-java">// Interface pour les stratÃ©gies de tri
public interface StrategieTriStrategy {
    void trier(int[] tableau);
    String getNom();
    String getComplexite();
}

// ImplÃ©mentations concrÃ¨tes des stratÃ©gies
public class TriBullesStrategy implements StrategieTriStrategy {
    @Override
    public void trier(int[] tableau) {
        System.out.println("Application du tri Ã  bulles...");
        int n = tableau.length;
        
        for (int i = 0; i < n - 1; i++) {
            for (int j = 0; j < n - i - 1; j++) {
                if (tableau[j] > tableau[j + 1]) {
                    // Ã‰change
                    int temp = tableau[j];
                    tableau[j] = tableau[j + 1];
                    tableau[j + 1] = temp;
                }
            }
        }
    }
    
    @Override
    public String getNom() { return "Tri Ã  Bulles"; }
    
    @Override
    public String getComplexite() { return "O(nÂ²)"; }
}

public class TriSelectionStrategy implements StrategieTriStrategy {
    @Override
    public void trier(int[] tableau) {
        System.out.println("Application du tri par sÃ©lection...");
        int n = tableau.length;
        
        for (int i = 0; i < n - 1; i++) {
            int indexMin = i;
            for (int j = i + 1; j < n; j++) {
                if (tableau[j] < tableau[indexMin]) {
                    indexMin = j;
                }
            }
            
            // Ã‰change
            int temp = tableau[i];
            tableau[i] = tableau[indexMin];
            tableau[indexMin] = temp;
        }
    }
    
    @Override
    public String getNom() { return "Tri par SÃ©lection"; }
    
    @Override
    public String getComplexite() { return "O(nÂ²)"; }
}

public class TriInsertionStrategy implements StrategieTriStrategy {
    @Override
    public void trier(int[] tableau) {
        System.out.println("Application du tri par insertion...");
        
        for (int i = 1; i < tableau.length; i++) {
            int elementCourant = tableau[i];
            int j = i - 1;
            
            while (j >= 0 && tableau[j] > elementCourant) {
                tableau[j + 1] = tableau[j];
                j--;
            }
            
            tableau[j + 1] = elementCourant;
        }
    }
    
    @Override
    public String getNom() { return "Tri par Insertion"; }
    
    @Override
    public String getComplexite() { return "O(nÂ²)"; }
}

// Contexte utilisant les stratÃ©gies
public class TrieurAvecStrategie {
    private StrategieTriStrategy strategie;
    
    public TrieurAvecStrategie(StrategieTriStrategy strategie) {
        this.strategie = strategie;
    }
    
    public void changerStrategie(StrategieTriStrategy nouvelleStrategie) {
        this.strategie = nouvelleStrategie;
        System.out.println("StratÃ©gie changÃ©e vers: " + nouvelleStrategie.getNom());
    }
    
    public void trierTableau(int[] tableau) {
        System.out.println("Tri avec " + strategie.getNom() + " (ComplexitÃ©: " + strategie.getComplexite() + ")");
        System.out.println("Avant: " + java.util.Arrays.toString(tableau));
        
        long debut = System.nanoTime();
        strategie.trier(tableau);
        long duree = System.nanoTime() - debut;
        
        System.out.println("AprÃ¨s: " + java.util.Arrays.toString(tableau));
        System.out.printf("Temps d'exÃ©cution: %.2f ms%n", duree / 1_000_000.0);
    }
}</code></pre>
                            </div>

                            <h4>2. Pattern Observer</h4>
                            <div class="code-block">
<pre><code class="language-java">// Interface pour les observateurs
public interface Observer {
    void update(String message);
    String getNom();
}

// Interface pour les sujets observÃ©s
public interface Subject {
    void ajouterObserver(Observer observer);
    void retirerObserver(Observer observer);
    void notifierObservers(String message);
}

// ImplÃ©mentation du sujet - Station mÃ©tÃ©o
public class StationMeteo implements Subject {
    private java.util.List<Observer> observers;
    private double temperature;
    private double humidite;
    private double pression;
    
    public StationMeteo() {
        this.observers = new java.util.ArrayList<>();
        System.out.println("Station mÃ©tÃ©o initialisÃ©e");
    }
    
    @Override
    public void ajouterObserver(Observer observer) {
        observers.add(observer);
        System.out.println("Observateur ajoutÃ©: " + observer.getNom());
    }
    
    @Override
    public void retirerObserver(Observer observer) {
        observers.remove(observer);
        System.out.println("Observateur retirÃ©: " + observer.getNom());
    }
    
    @Override
    public void notifierObservers(String message) {
        System.out.println("Notification Ã  " + observers.size() + " observateur(s): " + message);
        for (Observer observer : observers) {
            observer.update(message);
        }
    }
    
    public void changerConditions(double temp, double humid, double press) {
        this.temperature = temp;
        this.humidite = humid;
        this.pression = press;
        
        String message = String.format("Nouvelles conditions: %.1fÂ°C, %.1f%% humiditÃ©, %.1f hPa", 
                                      temp, humid, press);
        notifierObservers(message);
        
        // Alertes spÃ©ciales
        if (temp > 35) {
            notifierObservers("âš ï¸  ALERTE CANICULE: " + temp + "Â°C");
        }
        if (press < 1000) {
            notifierObservers("ğŸŒ§ï¸  ALERTE TEMPÃŠTE: Pression faible " + press + " hPa");
        }
    }
}

// Observateurs concrets
public class AffichageMobile implements Observer {
    private String nom;
    
    public AffichageMobile(String nom) {
        this.nom = nom;
    }
    
    @Override
    public void update(String message) {
        System.out.println("ğŸ“± [" + nom + "] " + message);
    }
    
    @Override
    public String getNom() { return nom; }
}

public class SystemeAlarme implements Observer {
    private String nom;
    private boolean alarmeActive;
    
    public SystemeAlarme(String nom) {
        this.nom = nom;
        this.alarmeActive = false;
    }
    
    @Override
    public void update(String message) {
        System.out.println("ğŸš¨ [" + nom + "] " + message);
        
        if (message.contains("ALERTE")) {
            alarmeActive = true;
            System.out.println("ğŸš¨ ALARME ACTIVÃ‰E par " + nom);
        }
    }
    
    @Override
    public String getNom() { return nom; }
}</code></pre>
                            </div>
                        </section>

                        <!-- Exercices -->
                        <section id="exercices" style="margin-bottom: 3rem;">
                            <h2 class="section-title">
                                <i class="fas fa-dumbbell"></i>
                                Exercices Pratiques sur les Interfaces (14 exercices)
                            </h2>

                            <!-- Exercice 1 -->
                            <div class="exercise-card">
                                <h4 style="color: var(--java-orange); margin-bottom: 1rem;">
                                    <i class="fas fa-gamepad"></i> Exercice 1 : SystÃ¨me de Jeu RPG Complet
                                </h4>
                                <p><strong>Objectif :</strong> CrÃ©er un systÃ¨me de jeu RPG avec interfaces pour les capacitÃ©s.</p>
                                <p><strong>Architecture :</strong></p>
                                <ul>
                                    <li><strong>Interfaces :</strong> Combattant, Magicien, Soigneur, Voleur</li>
                                    <li><strong>Classes :</strong> Guerrier, Mage, PrÃªtre, Assassin, Paladin (multi-interfaces)</li>
                                    <li><strong>SystÃ¨me :</strong> Combat, sorts, soins, vol, expÃ©rience</li>
                                </ul>
                                
                                <button class="btn btn-success btn-sm" type="button" data-bs-toggle="collapse" data-bs-target="#solution1">
                                    Voir la solution
                                </button>
                                
                                <div class="collapse mt-3" id="solution1">
                                    <div class="solution-card">
                                        <h6>Architecture ComplÃ¨te du Jeu RPG :</h6>
                                        <div class="code-block">
<pre><code class="language-java">// Interfaces pour les capacitÃ©s
public interface Combattant {
    int DEGATS_BASE = 10;
    
    void attaquer(Personnage cible);
    void parer();
    int calculerDegats();
    
    default void coupCritique(Personnage cible) {
        System.out.println("ğŸ’¥ COUP CRITIQUE !");
        int degats = calculerDegats() * 2;
        cible.recevoirDegats(degats);
    }
}

public interface Magicien {
    int MANA_MAX_BASE = 100;
    
    void lancerSort(String nomSort, Personnage cible);
    void restaurerMana(int quantite);
    int getManaActuel();
    
    default boolean peutLancerSort(int coutMana) {
        return getManaActuel() >= coutMana;
    }
}

public interface Soigneur {
    void soigner(Personnage cible);
    void soignerGroupe(Personnage[] groupe);
    
    default void resurrection(Personnage cible) {
        if (cible.estMort()) {
            cible.ressusciter();
            System.out.println("âœ¨ " + cible.getNom() + " a Ã©tÃ© ressuscitÃ© !");
        }
    }
}

// Classe de base abstraite
public abstract class Personnage {
    protected String nom;
    protected int niveau;
    protected int pointsVieMax;
    protected int pointsVieActuels;
    protected int experience;
    protected int experienceProchainNiveau;
    
    public Personnage(String nom, int pointsVieMax) {
        this.nom = nom;
        this.niveau = 1;
        this.pointsVieMax = pointsVieMax;
        this.pointsVieActuels = pointsVieMax;
        this.experience = 0;
        this.experienceProchainNiveau = 100;
    }
    
    public void recevoirDegats(int degats) {
        pointsVieActuels = Math.max(0, pointsVieActuels - degats);
        System.out.println(nom + " reÃ§oit " + degats + " dÃ©gÃ¢ts (PV: " + pointsVieActuels + "/" + pointsVieMax + ")");
        
        if (estMort()) {
            System.out.println("ğŸ’€ " + nom + " est mort !");
        }
    }
    
    public void gagnerExperience(int exp) {
        experience += exp;
        System.out.println(nom + " gagne " + exp + " XP (Total: " + experience + ")");
        
        while (experience >= experienceProchainNiveau) {
            monterNiveau();
        }
    }
    
    private void monterNiveau() {
        niveau++;
        experience -= experienceProchainNiveau;
        experienceProchainNiveau = niveau * 100;
        
        // Augmentation des stats
        pointsVieMax += 20;
        pointsVieActuels = pointsVieMax; // Soins complets au niveau
        
        System.out.println("ğŸ†™ " + nom + " monte au niveau " + niveau + " !");
        System.out.println("   PV max: " + pointsVieMax + " (+20)");
    }
    
    public boolean estMort() { return pointsVieActuels <= 0; }
    public void ressusciter() { pointsVieActuels = pointsVieMax / 2; }
    
    public abstract void utiliserCapaciteSpeciale();
    
    // Getters
    public String getNom() { return nom; }
    public int getNiveau() { return niveau; }
    public int getPointsVie() { return pointsVieActuels; }
}

// Classe Guerrier (Combattant)
public class Guerrier extends Personnage implements Combattant {
    private int force;
    private boolean enModeDefense;
    
    public Guerrier(String nom) {
        super(nom, 150); // Plus de PV
        this.force = 15;
        this.enModeDefense = false;
        System.out.println("âš”ï¸  Guerrier " + nom + " crÃ©Ã© (Force: " + force + ")");
    }
    
    @Override
    public void attaquer(Personnage cible) {
        if (estMort()) {
            System.out.println(nom + " ne peut pas attaquer (mort)");
            return;
        }
        
        int degats = calculerDegats();
        System.out.println("âš”ï¸  " + nom + " attaque " + cible.getNom() + " !");
        
        // Chance de coup critique (20%)
        if (Math.random() < 0.2) {
            coupCritique(cible);
        } else {
            cible.recevoirDegats(degats);
        }
        
        gagnerExperience(10);
    }
    
    @Override
    public void parer() {
        enModeDefense = true;
        System.out.println("ğŸ›¡ï¸  " + nom + " se met en position dÃ©fensive");
    }
    
    @Override
    public int calculerDegats() {
        int degats = DEGATS_BASE + force + (niveau * 2);
        if (enModeDefense) {
            degats /= 2; // Moins de dÃ©gÃ¢ts en dÃ©fense
            enModeDefense = false;
        }
        return degats;
    }
    
    @Override
    public void utiliserCapaciteSpeciale() {
        System.out.println("ğŸ”¥ " + nom + " utilise RAGE BERSERKER !");
        System.out.println("   Force doublÃ©e pour le prochain combat !");
        force *= 2;
    }
}

// Classe Mage (Magicien + Combattant)
public class Mage extends Personnage implements Magicien, Combattant {
    private int intelligence;
    private int manaActuel;
    private int manaMax;
    private String[] sortConnusus;
    private int nbSorts;
    
    public Mage(String nom) {
        super(nom, 80); // Moins de PV
        this.intelligence = 20;
        this.manaMax = 150;
        this.manaActuel = manaMax;
        this.sortConnusus = new String[10];
        this.nbSorts = 0;
        
        // Sorts de base
        apprendrSort("Boule de Feu");
        apprendrSort("Ã‰clair");
        apprendrSort("Bouclier Magique");
        
        System.out.println("ğŸ§™ Mage " + nom + " crÃ©Ã© (Intelligence: " + intelligence + ", Mana: " + manaMax + ")");
    }
    
    public void apprendrSort(String nomSort) {
        if (nbSorts < sortConnusus.length) {
            sortConnusus[nbSorts] = nomSort;
            nbSorts++;
            System.out.println("âœ¨ " + nom + " apprend le sort: " + nomSort);
        }
    }
    
    @Override
    public void lancerSort(String nomSort, Personnage cible) {
        if (estMort()) {
            System.out.println(nom + " ne peut pas lancer de sort (mort)");
            return;
        }
        
        // VÃ©rifier si le sort est connu
        boolean sortConnu = false;
        for (int i = 0; i < nbSorts; i++) {
            if (sortConnusus[i].equals(nomSort)) {
                sortConnu = true;
                break;
            }
        }
        
        if (!sortConnu) {
            System.out.println(nom + " ne connaÃ®t pas le sort: " + nomSort);
            return;
        }
        
        int coutMana = 0;
        int degats = 0;
        
        switch (nomSort) {
            case "Boule de Feu":
                coutMana = 25;
                degats = 30 + intelligence;
                break;
            case "Ã‰clair":
                coutMana = 20;
                degats = 25 + intelligence;
                break;
            case "Bouclier Magique":
                coutMana = 15;
                degats = 0; // Sort dÃ©fensif
                break;
        }
        
        if (peutLancerSort(coutMana)) {
            manaActuel -= coutMana;
            System.out.println("ğŸ”® " + nom + " lance " + nomSort + " sur " + cible.getNom());
            
            if (degats > 0) {
                cible.recevoirDegats(degats);
            } else {
                System.out.println("âœ¨ Bouclier magique activÃ© pour " + nom);
            }
            
            gagnerExperience(15);
        } else {
            System.out.println("Mana insuffisant pour " + nomSort + " (CoÃ»t: " + coutMana + ", Actuel: " + manaActuel + ")");
        }
    }
    
    @Override
    public void restaurerMana(int quantite) {
        manaActuel = Math.min(manaMax, manaActuel + quantite);
        System.out.println("ğŸ’™ " + nom + " restaure " + quantite + " mana (" + manaActuel + "/" + manaMax + ")");
    }
    
    @Override
    public int getManaActuel() { return manaActuel; }
    
    // ImplÃ©mentation de Combattant (attaque physique faible)
    @Override
    public void attaquer(Personnage cible) {
        System.out.println("ğŸª„ " + nom + " attaque avec son bÃ¢ton");
        cible.recevoirDegats(calculerDegats());
    }
    
    @Override
    public void parer() {
        System.out.println("ğŸ›¡ï¸  " + nom + " invoque un bouclier magique");
    }
    
    @Override
    public int calculerDegats() {
        return 5 + (intelligence / 3); // DÃ©gÃ¢ts physiques faibles
    }
    
    @Override
    public void utiliserCapaciteSpeciale() {
        System.out.println("ğŸŒŸ " + nom + " utilise MÃ‰TÃ‰ORE !");
        System.out.println("   Sort de zone dÃ©vastateur !");
        manaActuel = Math.max(0, manaActuel - 50);
    }
}</code></pre>
                                        </div>
                                    </div>
                                </div>
                            </div>
                        </section>

                        <!-- Navigation -->
                        <div style="display: flex; justify-content: space-between; margin-top: 3rem; padding-top: 2rem; border-top: 1px solid var(--border-color);">
                            <a href="module-6-heritage-polymorphisme.html" style="background: linear-gradient(135deg, var(--java-orange), var(--java-blue)); color: white; padding: 0.75rem 1.5rem; border-radius: 8px; text-decoration: none;">
                                <i class="fas fa-arrow-left me-2"></i>Module 6 : HÃ©ritage
                            </a>
                            <a href="module-8-gestion-exceptions.html" style="background: linear-gradient(135deg, var(--java-orange), var(--java-blue)); color: white; padding: 0.75rem 1.5rem; border-radius: 8px; text-decoration: none;">
                                Module 8 : Exceptions
                                <i class="fas fa-arrow-right ms-2"></i>
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
    
    <script>
        hljs.highlightAll();
        
        document.querySelectorAll('a[href^="#"]').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });
    </script>
</body>
</html>
