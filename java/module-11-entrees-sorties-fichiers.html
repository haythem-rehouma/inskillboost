<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Module 11 - Entr√©es/Sorties et Fichiers - Formation Java Compl√®te</title>
    
    <!-- Bootstrap 5 CSS -->
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
    
    <!-- Highlight.js CSS -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/github-dark.min.css">
    
    <!-- Font Awesome -->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    
    <!-- Google Fonts -->
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    
    <style>
        :root {
            --java-orange: #f89820;
            --java-blue: #5382a1;
            --success-color: #059669;
            --warning-color: #d97706;
            --info-color: #0284c7;
            --dark-color: #1f2937;
            --light-bg: #f8fafc;
            --border-color: #e2e8f0;
            --text-muted: #64748b;
            --question-bg: #f1f5f9;
            --answer-bg: #dcfce7;
            --explanation-bg: #fef3c7;
            --code-bg: #0f172a;
        }

        body {
            font-family: 'Inter', sans-serif;
            background-color: var(--light-bg);
            color: var(--dark-color);
            line-height: 1.6;
        }

        .navbar {
            background: linear-gradient(135deg, var(--java-orange), var(--java-blue));
            backdrop-filter: blur(10px);
        }

        .sidebar {
            position: sticky;
            top: 100px;
            height: calc(100vh - 120px);
            overflow-y: auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            padding: 1.5rem;
        }

        .main-content {
            background: white;
            border-radius: 12px;
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        .content-header {
            background: linear-gradient(135deg, var(--java-orange), var(--java-blue));
            color: white;
            padding: 2rem;
            text-align: center;
        }

        .section-title {
            color: var(--java-orange);
            font-weight: 700;
            font-size: 1.5rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .code-block {
            background: var(--code-bg);
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.9rem;
            overflow-x: auto;
        }

        .exercise-card {
            background: var(--question-bg);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1.5rem 0;
            border-left: 4px solid var(--java-orange);
        }

        .solution-card {
            background: var(--answer-bg);
            border-radius: 12px;
            padding: 1.5rem;
            margin: 1rem 0;
            border-left: 4px solid var(--success-color);
        }

        .concept-highlight {
            background: linear-gradient(135deg, rgba(248, 152, 32, 0.1), rgba(83, 130, 161, 0.1));
            border-radius: 8px;
            padding: 1rem;
            margin: 1rem 0;
            border-left: 4px solid var(--java-orange);
        }

        .progress-bar {
            background: linear-gradient(135deg, var(--java-orange), var(--java-blue));
            height: 100%;
            width: 91.67%; /* 11/12 modules */
            border-radius: 2px;
        }
    </style>
</head>
<body>
    <!-- Navigation -->
    <nav class="navbar navbar-expand-lg navbar-dark fixed-top">
        <div class="container">
            <a class="navbar-brand" href="../">
                <i class="fas fa-graduation-cap me-2"></i>
                InSkillBoost - Java
            </a>
            <div class="navbar-nav ms-auto">
                <a class="nav-link" href="../">Retour Hub</a>
                <a class="nav-link" href="./">Modules Java</a>
            </div>
        </div>
    </nav>

    <div class="container-fluid" style="margin-top: 80px;">
        <div class="row">
            <!-- Sidebar -->
            <div class="col-lg-3">
                <div class="sidebar">
                    <div style="color: var(--java-orange); font-weight: 600; margin-bottom: 1rem;">
                        <i class="fas fa-file-alt me-2"></i>
                        Module 11 - Entr√©es/Sorties et Fichiers
                    </div>
                    
                    <div style="background: var(--border-color); height: 4px; border-radius: 2px; margin: 1rem 0;">
                        <div class="progress-bar"></div>
                    </div>
                    <small class="text-muted d-block mb-3">Module 11 sur 12</small>
                    
                    <a href="#introduction-io" style="display: block; padding: 0.5rem 0; color: var(--java-orange); text-decoration: none;">Introduction I/O</a>
                    <a href="#fichiers-texte" style="display: block; padding: 0.5rem 0; color: var(--text-muted); text-decoration: none;">Fichiers Texte</a>
                    <a href="#fichiers-binaires" style="display: block; padding: 0.5rem 0; color: var(--text-muted); text-decoration: none;">Fichiers Binaires</a>
                    <a href="#nio2" style="display: block; padding: 0.5rem 0; color: var(--text-muted); text-decoration: none;">NIO.2 (Java 7+)</a>
                    <a href="#serialisation" style="display: block; padding: 0.5rem 0; color: var(--text-muted); text-decoration: none;">S√©rialisation</a>
                    <a href="#exercices" style="display: block; padding: 0.5rem 0; color: var(--text-muted); text-decoration: none;">Exercices (15)</a>
                </div>
            </div>

            <!-- Main Content -->
            <div class="col-lg-9">
                <div class="main-content">
                    <div class="content-header">
                        <h1>Module 11 - Entr√©es/Sorties et Fichiers</h1>
                        <p class="lead mb-0">Ma√Ætrisez la persistance et manipulation de donn√©es</p>
                    </div>

                    <div style="padding: 2rem;">
                        <!-- Introduction I/O -->
                        <section id="introduction-io" style="margin-bottom: 3rem;">
                            <h2 class="section-title">
                                <i class="fas fa-exchange-alt"></i>
                                Qu'est-ce que les Entr√©es/Sorties (I/O) ? Votre Pont vers le Monde Ext√©rieur !
                            </h2>
                            
                            <p>Les <strong>Entr√©es/Sorties (I/O)</strong> sont le moyen pour votre programme Java de <strong>communiquer avec le monde ext√©rieur</strong> ! C'est comme les sens d'un √™tre humain : les yeux pour voir (lire), la bouche pour parler (√©crire), les mains pour toucher (manipuler des fichiers).</p>

                            <div class="concept-highlight">
                                <h5>Analogie : I/O comme les Sens Humains</h5>
                                <ul>
                                    <li>üëÅÔ∏è <strong>Entr√©es (Input) :</strong> Lire des fichiers, saisies clavier, donn√©es r√©seau</li>
                                    <li>üëÑ <strong>Sorties (Output) :</strong> √âcrire des fichiers, afficher √† l'√©cran, envoyer sur r√©seau</li>
                                    <li>üß† <strong>Traitement :</strong> Votre programme Java qui analyse et transforme</li>
                                    <li>üíæ <strong>M√©moire :</strong> Stockage temporaire pendant le traitement</li>
                                </ul>
                            </div>

                            <h4>Pourquoi les I/O sont VITALES ?</h4>
                            <div class="code-block">
<pre><code class="language-java">/**
 * PROGRAMME SANS I/O : Inutile et isol√©
 */
public class SansIO {
    public static void main(String[] args) {
        // Programme qui ne peut rien faire d'utile
        int resultat = 2 + 2;
        String message = "Hello World";
        
        // Ces donn√©es restent PRISONNI√àRES du programme !
        // Impossible de :
        // - Sauvegarder le r√©sultat
        // - Lire des donn√©es externes
        // - Communiquer avec l'utilisateur
        // - Partager avec d'autres programmes
        
        System.out.println("Programme isol√© et inutile...");
    }
}

/**
 * PROGRAMME AVEC I/O : Puissant et utile !
 */
public class AvecIO {
    public static void main(String[] args) {
        try {
            // ENTR√âES : Lire des donn√©es
            System.out.println("=== PROGRAMME INTERACTIF ===");
            
            // Lire configuration depuis un fichier
            Properties config = new Properties();
            config.load(new FileInputStream("config.properties"));
            
            // Lire donn√©es utilisateur
            Scanner scanner = new Scanner(System.in);
            System.out.print("Votre nom : ");
            String nom = scanner.nextLine();
            
            // TRAITEMENT : Analyser et transformer
            String message = "Bonjour " + nom + "! Bienvenue dans " + config.getProperty("app.name");
            String timestamp = new Date().toString();
            
            // SORTIES : Sauvegarder et afficher
            // Afficher √† l'√©cran
            System.out.println(message);
            
            // Sauvegarder dans un fichier log
            PrintWriter log = new PrintWriter(new FileWriter("app.log", true));
            log.println(timestamp + " - Connexion de " + nom);
            log.close();
            
            // Sauvegarder donn√©es utilisateur
            PrintWriter userData = new PrintWriter(new FileWriter("users.txt", true));
            userData.println(nom + "," + timestamp);
            userData.close();
            
            System.out.println("‚úÖ Donn√©es sauvegard√©es !");
            
        } catch (IOException e) {
            System.out.println("‚ùå Erreur I/O: " + e.getMessage());
        }
    }
}

/*
AVANTAGES DES I/O :
‚úÖ Communication avec l'utilisateur
‚úÖ Persistance des donn√©es (survit √† l'arr√™t du programme)
‚úÖ Partage de donn√©es entre programmes
‚úÖ Configuration externe
‚úÖ Logs et tra√ßabilit√©
‚úÖ Int√©gration avec d'autres syst√®mes
*/</code></pre>
                            </div>

                            <h4>Les 3 G√©n√©rations d'I/O en Java</h4>
                            <div class="row">
                                <div class="col-md-4">
                                    <div class="concept-highlight">
                                        <h6>üìÅ Java I/O (Java 1.0)</h6>
                                        <p><strong>Classes de base</strong></p>
                                        <ul>
                                            <li>InputStream/OutputStream</li>
                                            <li>FileReader/FileWriter</li>
                                            <li>BufferedReader/BufferedWriter</li>
                                            <li>Bas√© sur les streams</li>
                                            <li>Gestion d'erreurs verbose</li>
                                        </ul>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="concept-highlight">
                                        <h6>üöÄ NIO (Java 1.4)</h6>
                                        <p><strong>New I/O</strong></p>
                                        <ul>
                                            <li>Channels et Buffers</li>
                                            <li>Non-blocking I/O</li>
                                            <li>S√©lecteurs pour performance</li>
                                            <li>M√©moire mapp√©e</li>
                                            <li>Plus complexe mais plus rapide</li>
                                        </ul>
                                    </div>
                                </div>
                                <div class="col-md-4">
                                    <div class="concept-highlight">
                                        <h6>‚ö° NIO.2 (Java 7+)</h6>
                                        <p><strong>Moderne et Simple</strong></p>
                                        <ul>
                                            <li>Path et Files</li>
                                            <li>Try-with-resources</li>
                                            <li>API simple et puissante</li>
                                            <li>Gestion d'erreurs √©l√©gante</li>
                                            <li>Recommand√© pour nouveaux projets</li>
                                        </ul>
                                    </div>
                                </div>
                            </div>
                            
                        </section>

                        <!-- Fichiers Texte -->
                        <section id="fichiers-texte" style="margin-bottom: 3rem;">
                            <h2 class="section-title">
                                <i class="fas fa-file-alt"></i>
                                Fichiers Texte : Votre Premier Contact avec la Persistance !
                            </h2>
                            
                            <p>Les <strong>fichiers texte</strong> sont le moyen le plus simple de sauvegarder des donn√©es ! C'est comme √©crire dans un carnet : vous pouvez l'ouvrir avec n'importe quel √©diteur de texte et voir exactement ce qui est √©crit.</p>

                            <div class="concept-highlight">
                                <h5>Analogie : Fichier Texte comme un Carnet</h5>
                                <ul>
                                    <li>üìù <strong>√âcriture :</strong> Ajouter des notes dans le carnet</li>
                                    <li>üëÄ <strong>Lecture :</strong> Relire ce qui a √©t√© √©crit</li>
                                    <li>üìÑ <strong>Lisible :</strong> N'importe qui peut ouvrir et comprendre</li>
                                    <li>üîÑ <strong>Modifiable :</strong> Peut √™tre √©dit√© avec n'importe quel √©diteur</li>
                                    <li>üíæ <strong>Permanent :</strong> Survit √† l'arr√™t du programme</li>
                                </ul>
                            </div>

                            <h4>M√©thodes Modernes (NIO.2) vs Anciennes (I/O)</h4>
                            <div class="code-block">
<pre><code class="language-java">import java.io.*;
import java.nio.file.*;
import java.util.*;

/**
 * COMPARAISON : Ancienne vs Nouvelle API
 */
public class ComparisonIO {
    public static void main(String[] args) {
        String nomFichier = "test.txt";
        String contenu = "Formation Java Compl√®te\nModule 11 - I/O\nC'est fantastique !";
        
        // === ANCIENNE M√âTHODE (Java I/O) ===
        System.out.println("=== ANCIENNE M√âTHODE (VERBEUSE) ===");
        ecrireAncienneMethode(nomFichier, contenu);
        lireAncienneMethode(nomFichier);
        
        // === NOUVELLE M√âTHODE (NIO.2) ===
        System.out.println("\n=== NOUVELLE M√âTHODE (√âL√âGANTE) ===");
        ecrireNouvelleMethode(nomFichier, contenu);
        lireNouvelleMethode(nomFichier);
    }
    
    // ANCIENNE M√âTHODE : Verbose et complexe
    public static void ecrireAncienneMethode(String nomFichier, String contenu) {
        FileWriter writer = null;
        BufferedWriter bufferedWriter = null;
        
        try {
            writer = new FileWriter(nomFichier);
            bufferedWriter = new BufferedWriter(writer);
            
            String[] lignes = contenu.split("\n");
            for (String ligne : lignes) {
                bufferedWriter.write(ligne);
                bufferedWriter.newLine();
            }
            
            System.out.println("‚úÖ √âcriture ancienne m√©thode r√©ussie");
            
        } catch (IOException e) {
            System.out.println("‚ùå Erreur √©criture: " + e.getMessage());
            
        } finally {
            // Fermeture manuelle (risque d'oubli !)
            try {
                if (bufferedWriter != null) bufferedWriter.close();
                if (writer != null) writer.close();
            } catch (IOException e) {
                System.out.println("‚ùå Erreur fermeture: " + e.getMessage());
            }
        }
    }
    
    public static void lireAncienneMethode(String nomFichier) {
        FileReader reader = null;
        BufferedReader bufferedReader = null;
        
        try {
            reader = new FileReader(nomFichier);
            bufferedReader = new BufferedReader(reader);
            
            String ligne;
            int numeroLigne = 1;
            System.out.println("Contenu (ancienne m√©thode):");
            
            while ((ligne = bufferedReader.readLine()) != null) {
                System.out.println(numeroLigne + ": " + ligne);
                numeroLigne++;
            }
            
        } catch (IOException e) {
            System.out.println("‚ùå Erreur lecture: " + e.getMessage());
            
        } finally {
            // Fermeture manuelle (encore !)
            try {
                if (bufferedReader != null) bufferedReader.close();
                if (reader != null) reader.close();
            } catch (IOException e) {
                System.out.println("‚ùå Erreur fermeture: " + e.getMessage());
            }
        }
    }
    
    // NOUVELLE M√âTHODE : Simple et √©l√©gante
    public static void ecrireNouvelleMethode(String nomFichier, String contenu) {
        try {
            // UNE SEULE LIGNE pour √©crire !
            Files.write(Paths.get(nomFichier), contenu.getBytes());
            System.out.println("‚úÖ √âcriture nouvelle m√©thode r√©ussie");
            
        } catch (IOException e) {
            System.out.println("‚ùå Erreur √©criture: " + e.getMessage());
        }
    }
    
    public static void lireNouvelleMethode(String nomFichier) {
        try {
            // UNE SEULE LIGNE pour lire !
            List<String> lignes = Files.readAllLines(Paths.get(nomFichier));
            
            System.out.println("Contenu (nouvelle m√©thode):");
            for (int i = 0; i < lignes.size(); i++) {
                System.out.println((i + 1) + ": " + lignes.get(i));
            }
            
        } catch (IOException e) {
            System.out.println("‚ùå Erreur lecture: " + e.getMessage());
        }
    }
}

/*
COMPARAISON CHOC :

ANCIENNE M√âTHODE :
‚ùå 40+ lignes de code
‚ùå Gestion manuelle des ressources
‚ùå Try-finally complexe
‚ùå Risque d'oubli de fermeture
‚ùå Code r√©p√©titif et verbeux

NOUVELLE M√âTHODE :
‚úÖ 2 lignes de code seulement !
‚úÖ Gestion automatique des ressources
‚úÖ Code lisible et maintenable
‚úÖ Fermeture automatique garantie
‚úÖ API moderne et intuitive

CONCLUSION : Utilisez TOUJOURS NIO.2 pour les nouveaux projets !
*/</code></pre>
                            </div>

                            <h4>Toutes les Fa√ßons de Lire et √âcrire des Fichiers</h4>
                            <div class="code-block">
<pre><code class="language-java">import java.io.*;
import java.nio.file.*;
import java.nio.charset.StandardCharsets;
import java.util.*;
import java.util.stream.*;

public class FichiersTexteMasterClass {
    public static void main(String[] args) {
        String nomFichier = "demo.txt";
        demonstrerEcritureFichiers(nomFichier);
        demonstrerLectureFichiers(nomFichier);
        demonstrerManipulationAvancee(nomFichier);
    }
    
    public static void demonstrerEcritureFichiers(String nomFichier) {
        System.out.println("=== TOUTES LES M√âTHODES D'√âCRITURE ===");
        
        // 1. √âcriture simple (remplace le contenu)
        try {
            String contenu = "Ligne 1\nLigne 2\nLigne 3";
            Files.write(Paths.get(nomFichier), contenu.getBytes());
            System.out.println("‚úÖ 1. √âcriture simple r√©ussie");
        } catch (IOException e) {
            System.out.println("‚ùå Erreur √©criture simple: " + e.getMessage());
        }
        
        // 2. √âcriture avec liste de lignes
        try {
            List<String> lignes = Arrays.asList(
                "=== NOUVEAU CONTENU ===",
                "Ligne A",
                "Ligne B", 
                "Ligne C avec caract√®res sp√©ciaux: √©√†√ß"
            );
            Files.write(Paths.get(nomFichier), lignes, StandardCharsets.UTF_8);
            System.out.println("‚úÖ 2. √âcriture avec liste r√©ussie");
        } catch (IOException e) {
            System.out.println("‚ùå Erreur √©criture liste: " + e.getMessage());
        }
        
        // 3. √âcriture en mode APPEND (ajout √† la fin)
        try {
            String ligneSupplementaire = "\n=== LIGNE AJOUT√âE ===\nCette ligne est ajout√©e √† la fin";
            Files.write(Paths.get(nomFichier), ligneSupplementaire.getBytes(), 
                       StandardOpenOption.APPEND);
            System.out.println("‚úÖ 3. Ajout en fin de fichier r√©ussi");
        } catch (IOException e) {
            System.out.println("‚ùå Erreur ajout: " + e.getMessage());
        }
        
        // 4. √âcriture avec BufferedWriter (pour gros volumes)
        try (BufferedWriter writer = Files.newBufferedWriter(Paths.get("gros_fichier.txt"))) {
            System.out.println("‚úÖ 4. Cr√©ation gros fichier...");
            
            for (int i = 1; i <= 1000; i++) {
                writer.write("Ligne " + i + " - Donn√©es importantes");
                writer.newLine();
                
                if (i % 100 == 0) {
                    System.out.println("   " + i + " lignes √©crites...");
                }
            }
            
            System.out.println("‚úÖ Gros fichier (1000 lignes) cr√©√© avec BufferedWriter");
            
        } catch (IOException e) {
            System.out.println("‚ùå Erreur gros fichier: " + e.getMessage());
        }
        
        // 5. √âcriture avec PrintWriter (formatage facile)
        try (PrintWriter writer = new PrintWriter(Files.newBufferedWriter(Paths.get("rapport.txt")))) {
            writer.println("=== RAPPORT AUTOMATIQUE ===");
            writer.printf("Date: %s%n", new Date());
            writer.printf("Utilisateur: %s%n", System.getProperty("user.name"));
            writer.printf("Syst√®me: %s%n", System.getProperty("os.name"));
            
            // Tableau format√©
            writer.println("\nStatistiques:");
            writer.printf("%-15s | %-10s | %-10s%n", "Produit", "Quantit√©", "Prix");
            writer.println("--------------------------------------------");
            writer.printf("%-15s | %-10d | %-10.2f‚Ç¨%n", "Laptop", 5, 999.99);
            writer.printf("%-15s | %-10d | %-10.2f‚Ç¨%n", "Souris", 20, 29.99);
            writer.printf("%-15s | %-10d | %-10.2f‚Ç¨%n", "Clavier", 10, 79.99);
            
            System.out.println("‚úÖ 5. Rapport format√© cr√©√© avec PrintWriter");
            
        } catch (IOException e) {
            System.out.println("‚ùå Erreur rapport: " + e.getMessage());
        }
    }
    
    public static void demonstrerLectureFichiers(String nomFichier) {
        System.out.println("\n=== TOUTES LES M√âTHODES DE LECTURE ===");
        
        // 1. Lecture compl√®te en String
        try {
            String contenuComplet = Files.readString(Paths.get(nomFichier));
            System.out.println("‚úÖ 1. Lecture compl√®te en String:");
            System.out.println("Taille: " + contenuComplet.length() + " caract√®res");
            System.out.println("Premi√®res 50 chars: " + contenuComplet.substring(0, Math.min(50, contenuComplet.length())) + "...");
            
        } catch (IOException e) {
            System.out.println("‚ùå Erreur lecture String: " + e.getMessage());
        }
        
        // 2. Lecture ligne par ligne en List
        try {
            List<String> lignes = Files.readAllLines(Paths.get(nomFichier));
            System.out.println("\n‚úÖ 2. Lecture ligne par ligne:");
            System.out.println("Nombre de lignes: " + lignes.size());
            
            for (int i = 0; i < Math.min(5, lignes.size()); i++) {
                System.out.printf("Ligne %d: %s%n", (i + 1), lignes.get(i));
            }
            
            if (lignes.size() > 5) {
                System.out.println("... (" + (lignes.size() - 5) + " lignes suppl√©mentaires)");
            }
            
        } catch (IOException e) {
            System.out.println("‚ùå Erreur lecture lignes: " + e.getMessage());
        }
        
        // 3. Lecture avec Stream (Java 8+) - Efficace pour gros fichiers
        try (Stream<String> lignes = Files.lines(Paths.get(nomFichier))) {
            System.out.println("\n‚úÖ 3. Lecture avec Stream:");
            
            // Compter les lignes non vides
            long lignesNonVides = lignes
                .filter(ligne -> !ligne.trim().isEmpty())
                .count();
            
            System.out.println("Lignes non vides: " + lignesNonVides);
            
        } catch (IOException e) {
            System.out.println("‚ùå Erreur lecture Stream: " + e.getMessage());
        }
        
        // 4. Lecture avec BufferedReader (contr√¥le total)
        try (BufferedReader reader = Files.newBufferedReader(Paths.get(nomFichier))) {
            System.out.println("\n‚úÖ 4. Lecture avec BufferedReader:");
            
            String ligne;
            int numeroLigne = 1;
            int caractereTotal = 0;
            
            while ((ligne = reader.readLine()) != null) {
                caractereTotal += ligne.length();
                
                if (numeroLigne <= 3) { // Afficher seulement les 3 premi√®res
                    System.out.printf("Ligne %d (%d chars): %s%n", numeroLigne, ligne.length(), ligne);
                }
                numeroLigne++;
            }
            
            System.out.printf("Total: %d lignes, %d caract√®res%n", numeroLigne - 1, caractereTotal);
            
        } catch (IOException e) {
            System.out.println("‚ùå Erreur BufferedReader: " + e.getMessage());
        }
        
        // 5. Lecture avec analyse en temps r√©el
        try (BufferedReader reader = Files.newBufferedReader(Paths.get(nomFichier))) {
            System.out.println("\n‚úÖ 5. Analyse en temps r√©el:");
            
            String ligne;
            Map<String, Integer> motsCles = new HashMap<>();
            motsCles.put("java", 0);
            motsCles.put("formation", 0);
            motsCles.put("module", 0);
            
            while ((ligne = reader.readLine()) != null) {
                String ligneLower = ligne.toLowerCase();
                
                for (String motCle : motsCles.keySet()) {
                    if (ligneLower.contains(motCle)) {
                        motsCles.put(motCle, motsCles.get(motCle) + 1);
                    }
                }
            }
            
            System.out.println("Mots-cl√©s trouv√©s:");
            motsCles.forEach((mot, count) -> 
                System.out.printf("  '%s': %d occurrence(s)%n", mot, count));
            
        } catch (IOException e) {
            System.out.println("‚ùå Erreur analyse: " + e.getMessage());
        }
    }
}</code></pre>
                            </div>

                            <h4>Gestion Avanc√©e des Fichiers avec NIO.2</h4>
                            <div class="code-block">
<pre><code class="language-java">import java.io.*;
import java.nio.file.*;
import java.nio.file.attribute.*;
import java.time.*;
import java.util.*;

public class GestionFichiersAvancee {
    public static void main(String[] args) {
        demonstrerOperationsFichiers();
        demonstrerAttributsFichiers();
        demonstrerGestionRepertoires();
    }
    
    public static void demonstrerOperationsFichiers() {
        System.out.println("=== OP√âRATIONS SUR FICHIERS ===");
        
        Path fichier = Paths.get("test_operations.txt");
        Path copie = Paths.get("test_copie.txt");
        Path renomme = Paths.get("test_renomme.txt");
        
        try {
            // Cr√©ation
            Files.write(fichier, "Contenu de test pour op√©rations".getBytes());
            System.out.println("‚úÖ Fichier cr√©√©: " + fichier.getFileName());
            
            // V√©rifications d'existence
            System.out.println("Fichier existe ? " + Files.exists(fichier));
            System.out.println("Est un fichier ? " + Files.isRegularFile(fichier));
            System.out.println("Est un r√©pertoire ? " + Files.isDirectory(fichier));
            System.out.println("Est lisible ? " + Files.isReadable(fichier));
            System.out.println("Est modifiable ? " + Files.isWritable(fichier));
            System.out.println("Est ex√©cutable ? " + Files.isExecutable(fichier));
            
            // Taille
            long taille = Files.size(fichier);
            System.out.println("Taille: " + taille + " octets");
            
            // Copie
            Files.copy(fichier, copie, StandardCopyOption.REPLACE_EXISTING);
            System.out.println("‚úÖ Fichier copi√© vers: " + copie.getFileName());
            
            // D√©placement/Renommage
            Files.move(copie, renomme, StandardCopyOption.REPLACE_EXISTING);
            System.out.println("‚úÖ Fichier renomm√© en: " + renomme.getFileName());
            
            // Suppression
            Files.delete(renomme);
            System.out.println("‚úÖ Fichier supprim√©: " + renomme.getFileName());
            
            // Suppression s√©curis√©e (pas d'erreur si n'existe pas)
            boolean supprime = Files.deleteIfExists(fichier);
            System.out.println("Fichier original supprim√©: " + supprime);
            
        } catch (IOException e) {
            System.out.println("‚ùå Erreur op√©ration: " + e.getMessage());
        }
    }
    
    public static void demonstrerAttributsFichiers() {
        System.out.println("\n=== ATTRIBUTS DE FICHIERS ===");
        
        Path fichier = Paths.get("fichier_attributs.txt");
        
        try {
            // Cr√©er un fichier avec du contenu
            Files.write(fichier, Arrays.asList(
                "Fichier de d√©monstration",
                "Cr√©√© le " + new Date(),
                "Pour tester les attributs"
            ));
            
            // Attributs de base
            BasicFileAttributes attrs = Files.readAttributes(fichier, BasicFileAttributes.class);
            
            System.out.println("=== INFORMATIONS FICHIER ===");
            System.out.println("Nom: " + fichier.getFileName());
            System.out.println("Chemin absolu: " + fichier.toAbsolutePath());
            System.out.println("Taille: " + attrs.size() + " octets");
            
            // Dates et heures
            FileTime creation = attrs.creationTime();
            FileTime modification = attrs.lastModifiedTime();
            FileTime acces = attrs.lastAccessTime();
            
            System.out.println("Cr√©√© le: " + Instant.ofEpochMilli(creation.toMillis()));
            System.out.println("Modifi√© le: " + Instant.ofEpochMilli(modification.toMillis()));
            System.out.println("Acc√©d√© le: " + Instant.ofEpochMilli(acces.toMillis()));
            
            // Type de fichier
            System.out.println("Est un fichier r√©gulier: " + attrs.isRegularFile());
            System.out.println("Est un r√©pertoire: " + attrs.isDirectory());
            System.out.println("Est un lien symbolique: " + attrs.isSymbolicLink());
            
            // Modification des attributs
            FileTime nouveauTemps = FileTime.fromMillis(System.currentTimeMillis());
            Files.setLastModifiedTime(fichier, nouveauTemps);
            System.out.println("‚úÖ Heure de modification mise √† jour");
            
            // Nettoyage
            Files.deleteIfExists(fichier);
            
        } catch (IOException e) {
            System.out.println("‚ùå Erreur attributs: " + e.getMessage());
        }
    }
    
    public static void demonstrerGestionRepertoires() {
        System.out.println("\n=== GESTION DES R√âPERTOIRES ===");
        
        Path dossier = Paths.get("test_dossier");
        Path sousDossier = dossier.resolve("sous_dossier");
        
        try {
            // Cr√©ation de r√©pertoires
            Files.createDirectories(sousDossier); // Cr√©e tous les dossiers parents n√©cessaires
            System.out.println("‚úÖ R√©pertoires cr√©√©s: " + sousDossier);
            
            // Cr√©er quelques fichiers de test
            for (int i = 1; i <= 3; i++) {
                Path fichier = dossier.resolve("fichier" + i + ".txt");
                Files.write(fichier, ("Contenu du fichier " + i).getBytes());
            }
            
            Path fichierSous = sousDossier.resolve("fichier_sous.txt");
            Files.write(fichierSous, "Fichier dans sous-dossier".getBytes());
            
            System.out.println("‚úÖ Fichiers de test cr√©√©s");
            
            // Lister le contenu d'un r√©pertoire
            System.out.println("\nContenu du r√©pertoire principal:");
            try (Stream<Path> fichiers = Files.list(dossier)) {
                fichiers.forEach(path -> {
                    try {
                        String type = Files.isDirectory(path) ? "[DIR]" : "[FILE]";
                        long taille = Files.isDirectory(path) ? 0 : Files.size(path);
                        System.out.printf("  %s %-20s (%d octets)%n", 
                                        type, path.getFileName(), taille);
                    } catch (IOException e) {
                        System.out.println("  Erreur lecture: " + path.getFileName());
                    }
                });
            }
            
            // Parcours r√©cursif (tous les fichiers et sous-dossiers)
            System.out.println("\nParcours r√©cursif complet:");
            try (Stream<Path> tousLesFichiers = Files.walk(dossier)) {
                tousLesFichiers
                    .filter(Files::isRegularFile) // Seulement les fichiers (pas les dossiers)
                    .forEach(path -> {
                        try {
                            long taille = Files.size(path);
                            String cheminRelatif = dossier.relativize(path).toString();
                            System.out.printf("  üìÑ %-25s (%d octets)%n", cheminRelatif, taille);
                        } catch (IOException e) {
                            System.out.println("  Erreur: " + path);
                        }
                    });
            }
            
            // Nettoyage r√©cursif
            System.out.println("\nüßπ Nettoyage...");
            supprimerRecursivement(dossier);
            
        } catch (IOException e) {
            System.out.println("‚ùå Erreur r√©pertoires: " + e.getMessage());
        }
    }
    
    // M√©thode utilitaire pour supprimer r√©cursivement
    public static void supprimerRecursivement(Path dossier) throws IOException {
        if (Files.exists(dossier)) {
            try (Stream<Path> fichiers = Files.walk(dossier)) {
                fichiers
                    .sorted(Comparator.reverseOrder()) // Supprimer enfants avant parents
                    .forEach(path -> {
                        try {
                            Files.delete(path);
                            System.out.println("  Supprim√©: " + path.getFileName());
                        } catch (IOException e) {
                            System.out.println("  Erreur suppression: " + path.getFileName());
                        }
                    });
            }
        }
    }
    
    public static void demonstrerManipulationAvancee(String nomFichier) {
        System.out.println("\n=== MANIPULATION AVANC√âE ===");
        
        // Cr√©er un fichier de test avec des donn√©es vari√©es
        Path fichier = Paths.get("donnees_avancees.txt");
        
        try {
            List<String> contenu = Arrays.asList(
                "# Configuration Application",
                "nom=MonApp",
                "version=1.2.3",
                "debug=true",
                "",
                "# Utilisateurs",
                "user1=admin:password123",
                "user2=guest:guest123",
                "",
                "# Statistiques",
                "connexions=1524",
                "erreurs=12",
                "uptime=99.7%"
            );
            
            Files.write(fichier, contenu);
            System.out.println("‚úÖ Fichier de donn√©es cr√©√©");
            
            // Analyse avec Stream API
            try (Stream<String> lignes = Files.lines(fichier)) {
                System.out.println("\nAnalyse du fichier:");
                
                Map<String, Long> statistiques = lignes
                    .collect(Collectors.groupingBy(ligne -> {
                        if (ligne.trim().isEmpty()) return "Lignes vides";
                        if (ligne.startsWith("#")) return "Commentaires";
                        if (ligne.contains("=")) return "Configurations";
                        return "Autres";
                    }, Collectors.counting()));
                
                statistiques.forEach((type, count) -> 
                    System.out.printf("  %s: %d%n", type, count));
            }
            
            // Extraction des configurations
            try (Stream<String> lignes = Files.lines(fichier)) {
                System.out.println("\nConfigurations extraites:");
                
                Map<String, String> configs = lignes
                    .filter(ligne -> ligne.contains("=") && !ligne.startsWith("#"))
                    .collect(Collectors.toMap(
                        ligne -> ligne.split("=")[0],
                        ligne -> ligne.split("=")[1]
                    ));
                
                configs.forEach((cle, valeur) -> 
                    System.out.printf("  %s ‚Üí %s%n", cle, valeur));
            }
            
            // Nettoyage
            Files.deleteIfExists(fichier);
            
        } catch (IOException e) {
            System.out.println("‚ùå Erreur manipulation avanc√©e: " + e.getMessage());
        }
    }
}

/*
R√âSUM√â DES M√âTHODES I/O :

√âCRITURE :
‚úÖ Files.write() ‚Üí Simple et rapide
‚úÖ Files.write() + APPEND ‚Üí Ajouter √† la fin
‚úÖ BufferedWriter ‚Üí Gros volumes
‚úÖ PrintWriter ‚Üí Formatage facile

LECTURE :
‚úÖ Files.readString() ‚Üí Tout en une String
‚úÖ Files.readAllLines() ‚Üí Liste de lignes
‚úÖ Files.lines() ‚Üí Stream (√©conome en m√©moire)
‚úÖ BufferedReader ‚Üí Contr√¥le total

OP√âRATIONS :
‚úÖ Files.copy() ‚Üí Copier
‚úÖ Files.move() ‚Üí D√©placer/Renommer
‚úÖ Files.delete() ‚Üí Supprimer
‚úÖ Files.exists() ‚Üí V√©rifier existence

RECOMMANDATION : Utilisez NIO.2 (Files.*) pour tous nouveaux projets !
*/</code></pre>
                            </div>
                        </section>

                        <!-- Fichiers Binaires -->
                        <section id="fichiers-binaires" style="margin-bottom: 3rem;">
                            <h2 class="section-title">
                                <i class="fas fa-file-code"></i>
                                Fichiers Binaires et S√©rialisation
                            </h2>
                            
                            <div class="code-block">
<pre><code class="language-java">import java.io.*;
import java.nio.file.*;
import java.util.*;

public class GestionFichiersComplete {
    public static void main(String[] args) {
        demonstrerLectureEcriture();
        demonstrerGestionCSV();
        demonstrerAnalyseurLogs();
    }
    
    public static void demonstrerLectureEcriture() {
        System.out.println("=== LECTURE/√âCRITURE FICHIERS ===");
        
        String nomFichier = "exemple.txt";
        
        // √âcriture avec try-with-resources
        try (BufferedWriter writer = Files.newBufferedWriter(Paths.get(nomFichier))) {
            writer.write("Formation Java Compl√®te\n");
            writer.write("Module 11 - Gestion des fichiers\n");
            writer.write("Ligne 3 avec caract√®res sp√©ciaux: √©√†√ß\n");
            writer.write("Nombres: 123, 456.78, -999\n");
            
            System.out.println("‚úÖ Fichier √©crit avec succ√®s");
            
        } catch (IOException e) {
            System.out.println("‚ùå Erreur d'√©criture: " + e.getMessage());
        }
        
        // Lecture ligne par ligne
        try (BufferedReader reader = Files.newBufferedReader(Paths.get(nomFichier))) {
            System.out.println("\nContenu du fichier:");
            String ligne;
            int numeroLigne = 1;
            
            while ((ligne = reader.readLine()) != null) {
                System.out.printf("%2d: %s%n", numeroLigne++, ligne);
            }
            
        } catch (IOException e) {
            System.out.println("‚ùå Erreur de lecture: " + e.getMessage());
        }
        
        // Lecture compl√®te en une fois (Java 8+)
        try {
            List&lt;String&gt; toutesLignes = Files.readAllLines(Paths.get(nomFichier));
            System.out.println("\nLecture compl√®te:");
            toutesLignes.forEach(ligne -&gt; System.out.println("‚Üí " + ligne));
            
        } catch (IOException e) {
            System.out.println("‚ùå Erreur de lecture compl√®te: " + e.getMessage());
        }
    }
    
    public static void demonstrerGestionCSV() {
        System.out.println("\n=== GESTION FICHIERS CSV ===");
        
        String fichierCSV = "employes.csv";
        
        // Cr√©ation d'un fichier CSV
        try (PrintWriter writer = new PrintWriter(Files.newBufferedWriter(Paths.get(fichierCSV)))) {
            writer.println("nom,prenom,age,salaire,departement");
            writer.println("Dupont,Jean,30,45000,IT");
            writer.println("Martin,Marie,25,38000,RH");
            writer.println("Durand,Pierre,35,52000,Finance");
            writer.println("Moreau,Sophie,28,41000,Marketing");
            writer.println("Bernard,Luc,42,58000,IT");
            
            System.out.println("‚úÖ Fichier CSV cr√©√©");
            
        } catch (IOException e) {
            System.out.println("‚ùå Erreur cr√©ation CSV: " + e.getMessage());
            return;
        }
        
        // Lecture et parsing du CSV
        try (BufferedReader reader = Files.newBufferedReader(Paths.get(fichierCSV))) {
            String ligne = reader.readLine(); // En-t√™tes
            System.out.println("En-t√™tes: " + ligne);
            System.out.println("\nEmploy√©s:");
            
            double totalSalaires = 0;
            int compteur = 0;
            Map&lt;String, Integer&gt; employesParDept = new HashMap&lt;&gt;();
            
            while ((ligne = reader.readLine()) != null) {
                String[] champs = ligne.split(",");
                
                if (champs.length == 5) {
                    String nom = champs[0];
                    String prenom = champs[1];
                    int age = Integer.parseInt(champs[2]);
                    double salaire = Double.parseDouble(champs[3]);
                    String dept = champs[4];
                    
                    System.out.printf("- %s %s (%d ans) - %s: %.0f‚Ç¨%n", 
                                    prenom, nom, age, dept, salaire);
                    
                    totalSalaires += salaire;
                    compteur++;
                    employesParDept.put(dept, employesParDept.getOrDefault(dept, 0) + 1);
                }
            }
            
            System.out.printf("\nStatistiques:%n");
            System.out.printf("- Total employ√©s: %d%n", compteur);
            System.out.printf("- Salaire moyen: %.2f‚Ç¨%n", totalSalaires / compteur);
            System.out.println("- R√©partition par d√©partement:");
            employesParDept.forEach((dept, nombre) -&gt; 
                System.out.printf("  %s: %d employ√©(s)%n", dept, nombre));
            
        } catch (IOException e) {
            System.out.println("‚ùå Erreur lecture CSV: " + e.getMessage());
        } catch (NumberFormatException e) {
            System.out.println("‚ùå Erreur format nombre dans CSV: " + e.getMessage());
        }
    }
}</code></pre>
                            </div>
                        </section>

                        <!-- Navigation -->
                        <div style="display: flex; justify-content: space-between; margin-top: 3rem; padding-top: 2rem; border-top: 1px solid var(--border-color);">
                            <a href="module-10-programmation-fonctionnelle.html" style="background: linear-gradient(135deg, var(--java-orange), var(--java-blue)); color: white; padding: 0.75rem 1.5rem; border-radius: 8px; text-decoration: none;">
                                <i class="fas fa-arrow-left me-2"></i>Module 10 : Fonctionnel
                            </a>
                            <a href="module-12-spring-boot-projets.html" style="background: linear-gradient(135deg, var(--java-orange), var(--java-blue)); color: white; padding: 0.75rem 1.5rem; border-radius: 8px; text-decoration: none;">
                                Module 12 : Spring Boot
                                <i class="fas fa-arrow-right ms-2"></i>
                            </a>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/java.min.js"></script>
    
    <script>
        hljs.highlightAll();
        
        document.querySelectorAll('a[href^="#"]').forEach(link => {
            link.addEventListener('click', function(e) {
                e.preventDefault();
                const target = document.querySelector(this.getAttribute('href'));
                if (target) {
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                }
            });
        });
    </script>
</body>
</html>
